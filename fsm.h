// Auto-generated by Python FSM generator. DO NOT EDIT.
#ifndef FSM_H_
#define FSM_H_

#include <stdint.h>

// ====== Enums ======
enum class State : uint8_t {
  IDLE,
  DISCONNECTED,
  CONNECTED,
  READY,
  STOPPED,
  PLAYING,
  PAUSED,
  ERROR
};

enum class Event : uint8_t {
  PORTSELECT,
  QUIT,
  RESET,
  CONNECT,
  DISCONNECT,
  ENABLE,
  DISABLE,
  PLAY,
  UPLOAD,
  PAUSE,
  STOP
};

// ====== Name tables ======
static constexpr const char* STATE_NAMES[] = {
  "IDLE",
  "DISCONNECTED",
  "CONNECTED",
  "READY",
  "STOPPED",
  "PLAYING",
  "PAUSED",
  "ERROR",
};
static constexpr const char* EVENT_NAMES[] = {
  "PORTSELECT",
  "QUIT",
  "RESET",
  "CONNECT",
  "DISCONNECT",
  "ENABLE",
  "DISABLE",
  "PLAY",
  "UPLOAD",
  "PAUSE",
  "STOP",
};
inline const char* fsm_state_name(State s) { return STATE_NAMES[(uint8_t)s]; }
inline const char* fsm_event_name(Event e) { return EVENT_NAMES[(uint8_t)e]; }

// ====== Transition table ======
struct Transition { State src; Event evt; State dst; };
static constexpr Transition TRANSITIONS[37] = {
  { State::IDLE, Event::PORTSELECT, State::DISCONNECTED },
  { State::IDLE, Event::QUIT, State::IDLE },
  { State::DISCONNECTED, Event::PORTSELECT, State::DISCONNECTED },
  { State::DISCONNECTED, Event::RESET, State::DISCONNECTED },
  { State::DISCONNECTED, Event::CONNECT, State::CONNECTED },
  { State::DISCONNECTED, Event::QUIT, State::IDLE },
  { State::CONNECTED, Event::DISCONNECT, State::DISCONNECTED },
  { State::CONNECTED, Event::RESET, State::DISCONNECTED },
  { State::CONNECTED, Event::ENABLE, State::STOPPED },
  { State::CONNECTED, Event::DISABLE, State::ERROR },
  { State::CONNECTED, Event::QUIT, State::IDLE },
  { State::READY, Event::DISCONNECT, State::DISCONNECTED },
  { State::READY, Event::RESET, State::DISCONNECTED },
  { State::READY, Event::PLAY, State::PLAYING },
  { State::READY, Event::DISABLE, State::ERROR },
  { State::READY, Event::QUIT, State::IDLE },
  { State::STOPPED, Event::DISCONNECT, State::DISCONNECTED },
  { State::STOPPED, Event::RESET, State::DISCONNECTED },
  { State::STOPPED, Event::UPLOAD, State::READY },
  { State::STOPPED, Event::DISABLE, State::ERROR },
  { State::STOPPED, Event::QUIT, State::IDLE },
  { State::PLAYING, Event::DISCONNECT, State::DISCONNECTED },
  { State::PLAYING, Event::RESET, State::DISCONNECTED },
  { State::PLAYING, Event::PAUSE, State::PAUSED },
  { State::PLAYING, Event::STOP, State::STOPPED },
  { State::PLAYING, Event::DISABLE, State::ERROR },
  { State::PLAYING, Event::QUIT, State::IDLE },
  { State::PAUSED, Event::DISCONNECT, State::DISCONNECTED },
  { State::PAUSED, Event::RESET, State::DISCONNECTED },
  { State::PAUSED, Event::PLAY, State::PLAYING },
  { State::PAUSED, Event::STOP, State::STOPPED },
  { State::PAUSED, Event::DISABLE, State::ERROR },
  { State::PAUSED, Event::QUIT, State::IDLE },
  { State::ERROR, Event::DISCONNECT, State::DISCONNECTED },
  { State::ERROR, Event::RESET, State::DISCONNECTED },
  { State::ERROR, Event::DISABLE, State::ERROR },
  { State::ERROR, Event::QUIT, State::IDLE },
};

// ====== Global state & API ======
static volatile State g_state = State::IDLE;
inline State fsm_state() { return g_state; }

// Check if event 'e' is valid from current state; optionally return next state.
inline bool isValid(Event e, State* out_next = nullptr) {
  const State s = g_state;
  for (uint16_t i = 0; i < (uint16_t)(sizeof(TRANSITIONS)/sizeof(TRANSITIONS[0])); ++i) {
    const Transition& t = TRANSITIONS[i];
    if (t.src == s && t.evt == e) {
      if (out_next) *out_next = t.dst;
      return true;
    }
  }
  return false;
}

// Commit transition if valid; returns true on state change.
inline bool fsm_trigger(Event e) {
  State next;
  if (!isValid(e, &next)) return false;
  g_state = next;
  return true;
}

#endif // FSM_H_