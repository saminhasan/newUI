# ────────original states/transitions, untouched ───────────────────────────────
states: list[str] = [
    "IDLE",
    "DISCONNECTED",
    "CONNECTED",
    "READY",
    "STOPPED",
    "PLAYING",
    "PAUSED",
    "ERROR",
]

transitions: list[dict[str, str | list[str]]] = [
    {"transition": "PORTSELECT", "source": "IDLE", "dest": "DISCONNECTED"},
    {"transition": "PORTSELECT", "source": "DISCONNECTED", "dest": "DISCONNECTED"},
    {"transition": "CONNECT", "source": "DISCONNECTED", "dest": "CONNECTED"},
    {"transition": "DISCONNECT", "source": states[1:], "dest": "DISCONNECTED"},
    {"transition": "ENABLE", "source": "CONNECTED", "dest": "STOPPED"},
    {"transition": "UPLOAD", "source": "STOPPED", "dest": "READY"},
    {"transition": "PLAY", "source": "READY", "dest": "PLAYING"},
    {"transition": "PAUSE", "source": "PLAYING", "dest": "PAUSED"},
    {"transition": "PLAY", "source": "PAUSED", "dest": "PLAYING"},
    {"transition": "STOP", "source": "PLAYING", "dest": "STOPPED"},
    {"transition": "STOP", "source": "PAUSED", "dest": "STOPPED"},
    {"transition": "RESET", "source": states[2:], "dest": "DISCONNECTED"},
    {"transition": "DISABLE", "source": states[2:], "dest": "ERROR"},
    {"transition": "QUIT", "source": states, "dest": "IDLE"},
]
# ─────────────────────────────────────────────────────────────────────────
import networkx as nx


class FSM:
    def __init__(
        self, states: list[str] = states, transitions: list[dict[str, str | list[str]]] = transitions, initial: str = ""
    ) -> None:
        # build the graph
        self._G: nx.MultiDiGraph = nx.MultiDiGraph()
        self._G.add_nodes_from(states)
        # flatten each transition’s source(s) into edges
        edges: list[tuple[str, str, str]] = [
            (src, t["dest"], t["transition"])
            for t in transitions
            for src in (t["source"] if isinstance(t["source"], list) else [t["source"]])
        ]
        for u, v, trig in edges:
            self._G.add_edge(u, v, transition=trig)
        # set initial state
        self.state: str = initial if initial else states[0]

    def trigger(self, name: str) -> str:
        """
        Fire a transition by trigger name.
        On success: updates self.state and returns the new state.
        On failure: raises ValueError.
        """
        # search outgoing edges for this transition
        for _, dest, key, data in self._G.out_edges(self.state, keys=True, data=True):
            if data["transition"] == name:
                self.state = dest
                return dest
        raise ValueError(f"No transition '{name}' from state '{self.state}'")

    def available_transitions(self) -> list[str]:
        """List all valid transitions from the current state."""
        return list({data["transition"] for _, _, _, data in self._G.out_edges(self.state, keys=True, data=True)})

    def __repr__(self) -> str:
        return f"<Current State={self.state!r}>"

    def print_fsm_h(self, path: str = "fsm.h", header_guard: str = "FSM_H_") -> None:
        """
        Minimal generator with name tables + two-step API:
        - isValid(Event e, State* out_next=nullptr): check/resolve next state
        - fsm_trigger(Event e): uses isValid(); commits on success
        """
        states = list(self._G.nodes)
        state_to_idx = {s: i for i, s in enumerate(states)}
        initial_state = self.state if self.state else states[0]

        # expand edges
        edges = []
        for u, v, k, data in self._G.edges(keys=True, data=True):
            edges.append((u, data["transition"], v))

        # event ordering by first appearance
        seen_events, events = set(), []
        for _, evt, _ in edges:
            if evt not in seen_events:
                seen_events.add(evt)
                events.append(evt)
        event_to_idx = {e: i for i, e in enumerate(events)}

        rows = [(state_to_idx[u], event_to_idx[evt], state_to_idx[v]) for (u, evt, v) in edges]

        import re

        def c_ident(s: str) -> str:
            s2 = re.sub(r"[^a-zA-Z0-9_]", "_", s)
            if re.match(r"^[0-9]", s2):
                s2 = "_" + s2
            return s2

        state_enum_vals = [c_ident(s) for s in states]
        event_enum_vals = [c_ident(e) for e in events]
        initial_ident = c_ident(initial_state)

        lines = []
        emit = lines.append

        emit("// Auto-generated by Python FSM generator. DO NOT EDIT.")
        emit(f"#ifndef {header_guard}")
        emit(f"#define {header_guard}")
        emit("")
        emit("#include <stdint.h>")
        emit("")
        emit("// ====== Enums ======")
        emit("enum class State : uint8_t {")
        for i, name in enumerate(state_enum_vals):
            comma = "," if i < len(state_enum_vals) - 1 else ""
            emit(f"  {name}{comma}")
        emit("};")
        emit("")
        emit("enum class Event : uint8_t {")
        for i, name in enumerate(event_enum_vals):
            comma = "," if i < len(event_enum_vals) - 1 else ""
            emit(f"  {name}{comma}")
        emit("};")
        emit("")
        emit("// ====== Name tables ======")
        emit("static constexpr const char* STATE_NAMES[] = {")
        for s in states:
            emit(f'  "{s}",')
        emit("};")
        emit("static constexpr const char* EVENT_NAMES[] = {")
        for e in events:
            emit(f'  "{e}",')
        emit("};")
        emit("inline const char* fsm_state_name(State s) { return STATE_NAMES[(uint8_t)s]; }")
        emit("inline const char* fsm_event_name(Event e) { return EVENT_NAMES[(uint8_t)e]; }")
        emit("")
        emit("// ====== Transition table ======")
        emit("struct Transition { State src; Event evt; State dst; };")
        emit(f"static constexpr Transition TRANSITIONS[{len(rows)}] = {{")
        for s_i, e_i, d_i in rows:
            emit(f"  {{ State::{state_enum_vals[s_i]}, Event::{event_enum_vals[e_i]}, State::{state_enum_vals[d_i]} }},")
        emit("};")
        emit("")
        emit("// ====== Global state & API ======")
        emit(f"static volatile State g_state = State::{initial_ident};")
        emit("inline State fsm_state() { return g_state; }")
        emit("")
        emit("// Check if event 'e' is valid from current state; optionally return next state.")
        emit("inline bool isValid(Event e, State* out_next = nullptr) {")
        emit("  const State s = g_state;")
        emit("  for (size_t  i = 0; i < (size_t )(sizeof(TRANSITIONS)/sizeof(TRANSITIONS[0])); ++i) {")
        emit("    const Transition& t = TRANSITIONS[i];")
        emit("    if (t.src == s && t.evt == e) {")
        emit("      if (out_next) *out_next = t.dst;")
        emit("      return true;")
        emit("    }")
        emit("  }")
        emit("  return false;")
        emit("}")
        emit("")
        emit("// Commit transition if valid; returns true on state change.")
        emit("inline bool fsm_trigger(Event e) {")
        emit("  State next;")
        emit("  if (!isValid(e, &next)) return false;")
        emit("  g_state = next;")
        emit("  return true;")
        emit("}")
        emit("")
        emit(f"#endif // {header_guard}")

        with open(path, "w", encoding="utf-8") as f:
            f.write("\n".join(lines))


def test() -> None:
    import random

    fsm: FSM = FSM(states, transitions, initial="IDLE")
    States: set[str] = set()
    while True:
        previous_state: str = fsm.state
        options: list[str] = fsm.available_transitions()
        random_event: str = random.choice(options)
        fsm.trigger(random_event)
        print(f"{previous_state} -> {random_event} -> {fsm.state}")
        States.add(fsm.state)
        if States == set(states):
            print("All states reached!")
            print("----------------------TEST PASSED----------------------")
            break


if __name__ == "__main__":
    # test()
    fsm: FSM = FSM(states, transitions, initial="IDLE")
    fsm.print_fsm_h(path="fsm.h", header_guard="FSM_H_")
