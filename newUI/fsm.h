// Auto-generated by Python FSM generator. DO NOT EDIT.
#ifndef FSM_H_
#define FSM_H_

#include <stdint.h>

// ====== Enums ======
enum class State : uint8_t 
{
  IDLE,
  DISCONNECTED,
  CONNECTED,
  READY,
  STOPPED,
  PLAYING,
  PAUSED,
  ERROR
};

enum class Event : uint8_t 
{
  IDLE_TO_DISCONNECTED,
  IDLE_TO_CONNECTED,
  IDLE_TO_READY,
  IDLE_TO_STOPPED,
  IDLE_TO_PLAYING,
  IDLE_TO_PAUSED,
  IDLE_TO_ERROR,
  DISCONNECTED_TO_IDLE,
  DISCONNECTED_TO_CONNECTED,
  DISCONNECTED_TO_READY,
  DISCONNECTED_TO_STOPPED,
  DISCONNECTED_TO_PLAYING,
  DISCONNECTED_TO_PAUSED,
  DISCONNECTED_TO_ERROR,
  CONNECTED_TO_IDLE,
  CONNECTED_TO_DISCONNECTED,
  CONNECTED_TO_READY,
  CONNECTED_TO_STOPPED,
  CONNECTED_TO_PLAYING,
  CONNECTED_TO_PAUSED,
  CONNECTED_TO_ERROR,
  READY_TO_IDLE,
  READY_TO_DISCONNECTED,
  READY_TO_CONNECTED,
  READY_TO_STOPPED,
  READY_TO_PLAYING,
  READY_TO_PAUSED,
  READY_TO_ERROR,
  STOPPED_TO_IDLE,
  STOPPED_TO_DISCONNECTED,
  STOPPED_TO_CONNECTED,
  STOPPED_TO_READY,
  STOPPED_TO_PLAYING,
  STOPPED_TO_PAUSED,
  STOPPED_TO_ERROR,
  PLAYING_TO_IDLE,
  PLAYING_TO_DISCONNECTED,
  PLAYING_TO_CONNECTED,
  PLAYING_TO_READY,
  PLAYING_TO_STOPPED,
  PLAYING_TO_PAUSED,
  PLAYING_TO_ERROR,
  PAUSED_TO_IDLE,
  PAUSED_TO_DISCONNECTED,
  PAUSED_TO_CONNECTED,
  PAUSED_TO_READY,
  PAUSED_TO_STOPPED,
  PAUSED_TO_PLAYING,
  PAUSED_TO_ERROR,
  ERROR_TO_IDLE,
  ERROR_TO_DISCONNECTED,
  ERROR_TO_CONNECTED,
  ERROR_TO_READY,
  ERROR_TO_STOPPED,
  ERROR_TO_PLAYING,
  ERROR_TO_PAUSED
};

// ====== Name tables ======
static constexpr const char* STATE_NAMES[] = 
{
  "IDLE",
  "DISCONNECTED",
  "CONNECTED",
  "READY",
  "STOPPED",
  "PLAYING",
  "PAUSED",
  "ERROR",
};

static constexpr const char* EVENT_NAMES[] = 
{
  "IDLE_TO_DISCONNECTED",
  "IDLE_TO_CONNECTED",
  "IDLE_TO_READY",
  "IDLE_TO_STOPPED",
  "IDLE_TO_PLAYING",
  "IDLE_TO_PAUSED",
  "IDLE_TO_ERROR",
  "DISCONNECTED_TO_IDLE",
  "DISCONNECTED_TO_CONNECTED",
  "DISCONNECTED_TO_READY",
  "DISCONNECTED_TO_STOPPED",
  "DISCONNECTED_TO_PLAYING",
  "DISCONNECTED_TO_PAUSED",
  "DISCONNECTED_TO_ERROR",
  "CONNECTED_TO_IDLE",
  "CONNECTED_TO_DISCONNECTED",
  "CONNECTED_TO_READY",
  "CONNECTED_TO_STOPPED",
  "CONNECTED_TO_PLAYING",
  "CONNECTED_TO_PAUSED",
  "CONNECTED_TO_ERROR",
  "READY_TO_IDLE",
  "READY_TO_DISCONNECTED",
  "READY_TO_CONNECTED",
  "READY_TO_STOPPED",
  "READY_TO_PLAYING",
  "READY_TO_PAUSED",
  "READY_TO_ERROR",
  "STOPPED_TO_IDLE",
  "STOPPED_TO_DISCONNECTED",
  "STOPPED_TO_CONNECTED",
  "STOPPED_TO_READY",
  "STOPPED_TO_PLAYING",
  "STOPPED_TO_PAUSED",
  "STOPPED_TO_ERROR",
  "PLAYING_TO_IDLE",
  "PLAYING_TO_DISCONNECTED",
  "PLAYING_TO_CONNECTED",
  "PLAYING_TO_READY",
  "PLAYING_TO_STOPPED",
  "PLAYING_TO_PAUSED",
  "PLAYING_TO_ERROR",
  "PAUSED_TO_IDLE",
  "PAUSED_TO_DISCONNECTED",
  "PAUSED_TO_CONNECTED",
  "PAUSED_TO_READY",
  "PAUSED_TO_STOPPED",
  "PAUSED_TO_PLAYING",
  "PAUSED_TO_ERROR",
  "ERROR_TO_IDLE",
  "ERROR_TO_DISCONNECTED",
  "ERROR_TO_CONNECTED",
  "ERROR_TO_READY",
  "ERROR_TO_STOPPED",
  "ERROR_TO_PLAYING",
  "ERROR_TO_PAUSED",
};
inline const char* fsm_state_name(State s) { return STATE_NAMES[(uint8_t)s]; }
inline const char* fsm_event_name(Event e) { return EVENT_NAMES[(uint8_t)e]; }

// ====== Transition table ======
struct Transition { State src; Event evt; State dst; };
static constexpr Transition TRANSITIONS[56] = 
{
  { State::IDLE, Event::IDLE_TO_DISCONNECTED, State::DISCONNECTED },
  { State::IDLE, Event::IDLE_TO_CONNECTED, State::CONNECTED },
  { State::IDLE, Event::IDLE_TO_READY, State::READY },
  { State::IDLE, Event::IDLE_TO_STOPPED, State::STOPPED },
  { State::IDLE, Event::IDLE_TO_PLAYING, State::PLAYING },
  { State::IDLE, Event::IDLE_TO_PAUSED, State::PAUSED },
  { State::IDLE, Event::IDLE_TO_ERROR, State::ERROR },
  { State::DISCONNECTED, Event::DISCONNECTED_TO_IDLE, State::IDLE },
  { State::DISCONNECTED, Event::DISCONNECTED_TO_CONNECTED, State::CONNECTED },
  { State::DISCONNECTED, Event::DISCONNECTED_TO_READY, State::READY },
  { State::DISCONNECTED, Event::DISCONNECTED_TO_STOPPED, State::STOPPED },
  { State::DISCONNECTED, Event::DISCONNECTED_TO_PLAYING, State::PLAYING },
  { State::DISCONNECTED, Event::DISCONNECTED_TO_PAUSED, State::PAUSED },
  { State::DISCONNECTED, Event::DISCONNECTED_TO_ERROR, State::ERROR },
  { State::CONNECTED, Event::CONNECTED_TO_IDLE, State::IDLE },
  { State::CONNECTED, Event::CONNECTED_TO_DISCONNECTED, State::DISCONNECTED },
  { State::CONNECTED, Event::CONNECTED_TO_READY, State::READY },
  { State::CONNECTED, Event::CONNECTED_TO_STOPPED, State::STOPPED },
  { State::CONNECTED, Event::CONNECTED_TO_PLAYING, State::PLAYING },
  { State::CONNECTED, Event::CONNECTED_TO_PAUSED, State::PAUSED },
  { State::CONNECTED, Event::CONNECTED_TO_ERROR, State::ERROR },
  { State::READY, Event::READY_TO_IDLE, State::IDLE },
  { State::READY, Event::READY_TO_DISCONNECTED, State::DISCONNECTED },
  { State::READY, Event::READY_TO_CONNECTED, State::CONNECTED },
  { State::READY, Event::READY_TO_STOPPED, State::STOPPED },
  { State::READY, Event::READY_TO_PLAYING, State::PLAYING },
  { State::READY, Event::READY_TO_PAUSED, State::PAUSED },
  { State::READY, Event::READY_TO_ERROR, State::ERROR },
  { State::STOPPED, Event::STOPPED_TO_IDLE, State::IDLE },
  { State::STOPPED, Event::STOPPED_TO_DISCONNECTED, State::DISCONNECTED },
  { State::STOPPED, Event::STOPPED_TO_CONNECTED, State::CONNECTED },
  { State::STOPPED, Event::STOPPED_TO_READY, State::READY },
  { State::STOPPED, Event::STOPPED_TO_PLAYING, State::PLAYING },
  { State::STOPPED, Event::STOPPED_TO_PAUSED, State::PAUSED },
  { State::STOPPED, Event::STOPPED_TO_ERROR, State::ERROR },
  { State::PLAYING, Event::PLAYING_TO_IDLE, State::IDLE },
  { State::PLAYING, Event::PLAYING_TO_DISCONNECTED, State::DISCONNECTED },
  { State::PLAYING, Event::PLAYING_TO_CONNECTED, State::CONNECTED },
  { State::PLAYING, Event::PLAYING_TO_READY, State::READY },
  { State::PLAYING, Event::PLAYING_TO_STOPPED, State::STOPPED },
  { State::PLAYING, Event::PLAYING_TO_PAUSED, State::PAUSED },
  { State::PLAYING, Event::PLAYING_TO_ERROR, State::ERROR },
  { State::PAUSED, Event::PAUSED_TO_IDLE, State::IDLE },
  { State::PAUSED, Event::PAUSED_TO_DISCONNECTED, State::DISCONNECTED },
  { State::PAUSED, Event::PAUSED_TO_CONNECTED, State::CONNECTED },
  { State::PAUSED, Event::PAUSED_TO_READY, State::READY },
  { State::PAUSED, Event::PAUSED_TO_STOPPED, State::STOPPED },
  { State::PAUSED, Event::PAUSED_TO_PLAYING, State::PLAYING },
  { State::PAUSED, Event::PAUSED_TO_ERROR, State::ERROR },
  { State::ERROR, Event::ERROR_TO_IDLE, State::IDLE },
  { State::ERROR, Event::ERROR_TO_DISCONNECTED, State::DISCONNECTED },
  { State::ERROR, Event::ERROR_TO_CONNECTED, State::CONNECTED },
  { State::ERROR, Event::ERROR_TO_READY, State::READY },
  { State::ERROR, Event::ERROR_TO_STOPPED, State::STOPPED },
  { State::ERROR, Event::ERROR_TO_PLAYING, State::PLAYING },
  { State::ERROR, Event::ERROR_TO_PAUSED, State::PAUSED },
};

// ====== Global state & API ======
static volatile State g_state = State::IDLE;
inline State fsm_state() { return g_state; }

// Check if event 'e' is valid from current state; optionally return next state.
inline bool isValid(Event e, State* out_next = nullptr) 
{
  const State s = g_state;
  for (size_t  i = 0; i < (size_t )(sizeof(TRANSITIONS)/sizeof(TRANSITIONS[0])); ++i)
    {
      const Transition& t = TRANSITIONS[i];
        if (t.src == s && t.evt == e) 
        {
          if (out_next) *out_next = t.dst;
          return true;
        }
    }
  return false;
}

// Commit transition if valid; returns true on state change.
inline bool fsm_trigger(Event e) 
{
  State next;
  if (!isValid(e, &next)) return false;
  g_state = next;
  return true;
}

#endif // FSM_H_